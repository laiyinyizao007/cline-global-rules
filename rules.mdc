# 通用编码规则

**所有模式下都应遵循的核心原则**

---

## 项目配置

### 默认项目路径
- **默认工作目录：** `C:\Dev\projects\`
- **规则：** 当用户创建新项目或只提供项目名时，自动使用此路径
- **示例：**
  - 用户说："创建一个名为 bookmark-manager 的项目"
  - 自动解释为：`C:\Dev\projects\bookmark-manager`
  - 用户说："新建项目 todo-app"
  - 自动解释为：`C:\Dev\projects\todo-app`

### 项目初始化流程
1. **确定项目路径**
   - 如果用户只提供项目名 → 使用 `C:\Dev\projects\[项目名]`
   - 如果用户提供完整路径 → 使用用户指定的路径

2. **创建项目目录**
   ```powershell
   cd C:\Dev\projects
   mkdir [项目名]
   cd [项目名]
   ```

3. **复制 Rules Template**
   ```powershell
   cp -r C:\Dev\projects\rules_template\* .
   ```

4. **初始化项目**
   - Git 初始化
   - 根据技术栈初始化（npm、pip 等）
   - 在 VS Code 中打开

### 使用示例

**场景 1：用户只说项目名**
```
用户："创建一个书签管理器项目"
AI 理解为：C:\Dev\projects\bookmark-manager
```

**场景 2：用户指定完整路径**
```
用户："在 D:\work\my-app 创建项目"
AI 使用：D:\work\my-app
```

**场景 3：用户说"新项目"**
```
用户："新建项目 blog-system"
AI 理解为：C:\Dev\projects\blog-system
```

---

## 依赖管理

### 依赖安装规则

**原则：所有依赖都应该安装在项目本地，而不是全局**

### 依赖分类

#### 1. 运行时依赖（dependencies）
安装在项目本地，使用 `--save`（或省略，npm 5+ 默认）

**包括：**
- Web 框架：`express`, `koa`, `fastify`
- 数据库：`sqlite3`, `better-sqlite3`, `lowdb`, `mongoose`, `pg`
- 工具库：`lodash`, `axios`, `moment`, `dayjs`
- 模板引擎：`ejs`, `pug`, `handlebars`
- 中间件：`body-parser`, `cors`, `helmet`

**安装命令：**
```powershell
npm install express body-parser --save
# 或简写（npm 5+ 默认 --save）
npm install express body-parser
```

#### 2. 开发依赖（devDependencies）
安装在项目本地，使用 `--save-dev`

**包括：**
- 测试框架：`jest`, `mocha`, `chai`
- 构建工具：`webpack`, `vite`, `rollup`
- 代码检查：`eslint`, `prettier`
- 类型检查：`typescript`, `@types/*`
- 开发服务器：`nodemon`, `webpack-dev-server`
- 预处理器：`sass`, `less`, `babel`

**安装命令：**
```powershell
npm install nodemon jest eslint --save-dev
```

#### 3. 全局工具（仅限 CLI 工具）
**极少使用全局安装，优先使用项目本地 + npx**

**可以全局安装的：**
- 项目生成器：`create-react-app`, `vue-cli`, `@angular/cli`
- 包管理器：`yarn`, `pnpm`
- 进程管理：`pm2`
- 系统工具：`http-server`, `serve`

**安装命令：**
```powershell
npm install -g create-react-app
```

### 自动判断规则

**当用户要求安装依赖时，AI 应该：**

1. **分析依赖类型**
   - 查看包名和用途
   - 确定是运行时依赖还是开发依赖

2. **选择安装位置**
   ```
   运行时需要 → dependencies (--save)
   仅开发使用 → devDependencies (--save-dev)
   CLI 工具    → devDependencies (--save-dev) + npm scripts
   ```

3. **推荐运行方式**
   ```powershell
   # ❌ 不推荐：全局安装
   npm install -g nodemon
   nodemon server.js
   
   # ✅ 推荐：本地安装 + npm scripts
   npm install nodemon --save-dev
   # 在 package.json 中添加：
   # "scripts": { "dev": "nodemon server.js" }
   npm run dev
   ```

### 安装示例

#### Web 项目（Node.js + Express）
```powershell
# 运行时依赖
npm install express body-parser cors helmet

# 开发依赖
npm install nodemon --save-dev

# package.json scripts
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  }
}
```

#### React 项目
```powershell
# 创建项目（全局工具）
npx create-react-app my-app

# 额外依赖
cd my-app
npm install axios react-router-dom

# 开发依赖
npm install eslint prettier --save-dev
```

#### TypeScript 项目
```powershell
# 开发依赖（TypeScript 本身）
npm install typescript @types/node --save-dev

# 运行时依赖
npm install express
npm install @types/express --save-dev

# package.json scripts
{
  "scripts": {
    "build": "tsc",
    "dev": "ts-node src/index.ts",
    "start": "node dist/index.js"
  }
}
```

### 常见依赖分类表

| 依赖包 | 类型 | 原因 |
|--------|------|------|
| express | dependencies | 运行时需要 |
| body-parser | dependencies | 运行时需要 |
| sqlite3 | dependencies | 运行时需要 |
| lowdb | dependencies | 运行时需要 |
| axios | dependencies | 运行时需要 |
| nodemon | devDependencies | 仅开发时使用 |
| jest | devDependencies | 仅测试时使用 |
| eslint | devDependencies | 仅开发时检查 |
| typescript | devDependencies | 编译后不需要 |
| webpack | devDependencies | 构建工具 |

### 特殊情况处理

#### 情况 1：原生模块编译失败（如 sqlite3）
```
问题：需要 Visual Studio 构建工具

方案 A：使用纯 JS 替代
npm install lowdb  # 替代 sqlite3

方案 B：提示用户安装构建工具
提示："需要安装 Visual Studio Build Tools
下载：https://visualstudio.microsoft.com/downloads/"

方案 C：使用预编译版本
npm install better-sqlite3  # 通常有预编译版本
```

#### 情况 2：版本冲突
```
检查 package.json 中的版本
使用 npm ls [package] 查看依赖树
必要时使用 npm install [package]@[version]
```

### 最佳实践总结

1. ✅ **项目本地安装**
   - 保证项目可移植性
   - 不同项目可以使用不同版本
   - 团队成员环境一致

2. ✅ **使用 package.json scripts**
   - 统一运行方式
   - 自动使用本地依赖
   - 文档化常用命令

3. ✅ **区分 dependencies 和 devDependencies**
   - 生产环境只安装 dependencies
   - 减小部署包大小

4. ✅ **使用 npx 运行一次性工具**
   ```powershell
   npx create-react-app my-app
   npx eslint --init
   ```

5. ❌ **避免全局安装项目依赖**
   - 版本管理困难
   - 环境不一致
   - 团队协作问题

---

## 核心原则

### 1. 清晰沟通
- 使用简洁明了的语言
- 提供具体的上下文信息
- 明确说明期望的结果
- 逐步分解复杂任务

### 2. 代码质量
- 遵循 Clean Code 原则
- 编写可读性强的代码
- 添加必要的注释和文档
- 保持代码简洁（KISS 原则）
- 避免重复代码（DRY 原则）
- 单一职责原则（SRP）

### 3. 最佳实践
- 遵循项目现有的代码风格
- 使用有意义的变量和函数命名
- 编写可测试的代码
- 注重性能和安全性

---

## 编码原则

### SOLID 原则
- **S** - Single Responsibility（单一职责）
- **O** - Open/Closed（开闭原则）
- **L** - Liskov Substitution（里氏替换）
- **I** - Interface Segregation（接口隔离）
- **D** - Dependency Inversion（依赖倒置）

### 其他重要原则
- **KISS** - Keep It Simple, Stupid
- **DRY** - Don't Repeat Yourself
- **YAGNI** - You Aren't Gonna Need It
- **Composition over Inheritance** - 组合优于继承

---

## 命名规范

### 变量命名
```python
# ✅ 好的命名
user_count = 10
is_active = True
customer_list = []
MAX_RETRY_ATTEMPTS = 3

# ❌ 避免的命名
n = 10
flag = True
data = []
x = 3
```

### 函数命名
```python
# ✅ 好的命名 - 动词开头，描述性强
def calculate_total_price(items):
    pass

def validate_user_input(input_data):
    pass

def fetch_user_by_id(user_id):
    pass

# ❌ 避免的命名
def process():
    pass

def do_something(x):
    pass
```

### 类命名
```python
# ✅ 好的命名 - 名词，帕斯卡命名法
class UserAccount:
    pass

class OrderProcessor:
    pass

class DatabaseConnection:
    pass

# ❌ 避免的命名
class Data:
    pass

class Manager:
    pass
```

---

## 函数设计

### 函数长度
- 函数应该简短（通常 < 20 行）
- 一个函数只做一件事
- 如果函数太长，考虑拆分

### 参数数量
```python
# ✅ 好的设计 - 参数少
def create_user(name, email):
    pass

# ⚠️ 参数过多 - 考虑使用对象或字典
def create_user(name, email, phone, address, city, state, zip_code, country):
    pass

# ✅ 更好的设计
def create_user(user_data: dict):
    pass
```

### 返回值
- 保持返回类型一致
- 使用明确的返回值
- 避免副作用

---

## 注释和文档

### 何时添加注释
```python
# ✅ 解释"为什么"而不是"是什么"
# 使用缓存避免重复计算，提高性能
cache = {}

# ❌ 重复代码逻辑
# 创建一个空字典
cache = {}
```

### 文档字符串
```python
def calculate_discount(price, discount_rate):
    """
    计算折扣后的价格
    
    Args:
        price (float): 原价
        discount_rate (float): 折扣率 (0-1之间)
    
    Returns:
        float: 折扣后的价格
    
    Raises:
        ValueError: 如果折扣率不在有效范围内
    
    Example:
        >>> calculate_discount(100, 0.2)
        80.0
    """
    if not 0 <= discount_rate <= 1:
        raise ValueError("折扣率必须在 0-1 之间")
    return price * (1 - discount_rate)
```

---

## 错误处理

### 使用具体的异常
```python
# ✅ 具体的异常类型
try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    logger.error(f"除零错误: {e}")
    raise
except ValueError as e:
    logger.error(f"值错误: {e}")
    raise

# ❌ 捕获所有异常
try:
    result = divide(10, 0)
except:
    pass  # 永远不要这样做！
```

### 提供有用的错误信息
```python
# ✅ 清晰的错误信息
if age < 0:
    raise ValueError(f"年龄不能为负数，当前值: {age}")

if not email:
    raise ValueError("邮箱地址不能为空")

# ❌ 模糊的错误信息
if age < 0:
    raise ValueError("Invalid age")
```

---

## 安全实践

### 1. 避免硬编码敏感信息
```python
# ✅ 使用环境变量
import os
API_KEY = os.getenv('API_KEY')
DB_PASSWORD = os.getenv('DB_PASSWORD')

# ❌ 硬编码
API_KEY = 'sk-1234567890abcdef'  # 永远不要这样做！
```

### 2. 输入验证
```python
# ✅ 验证用户输入
def process_user_input(user_input):
    if not isinstance(user_input, str):
        raise TypeError("输入必须是字符串")
    if len(user_input) > 1000:
        raise ValueError("输入过长")
    # 清理和处理输入
    return user_input.strip()
```

### 3. SQL 注入防护
```python
# ✅ 使用参数化查询
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

# ❌ 字符串拼接
cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
```

---

## 性能考虑

### 1. 选择合适的数据结构
```python
# ✅ 查找操作使用字典/集合
user_dict = {user['id']: user for user in users}
user = user_dict.get(user_id)

# ❌ 频繁查找使用列表
user = next((u for u in users if u['id'] == user_id), None)
```

### 2. 避免过早优化
- 先写清晰的代码
- 测量性能瓶颈
- 然后有针对性地优化

---

## 测试原则

### 1. 编写可测试的代码
```python
# ✅ 可测试 - 依赖注入
def send_email(email_service, recipient, message):
    return email_service.send(recipient, message)

# ❌ 难以测试 - 硬编码依赖
def send_email(recipient, message):
    email_service = EmailService()
    return email_service.send(recipient, message)
```

### 2. 测试命名
```python
# ✅ 描述性的测试名称
def test_calculate_discount_with_valid_rate():
    pass

def test_calculate_discount_raises_error_for_invalid_rate():
    pass
```

---

## 中文编码规范参考

本规则整合了以下中文编码规范：

**详细规范：**
- **C:\Dev\rules\ai-instructions\general-rules.md** - 完整的中文编码规范
- **C:\Dev\rules\ai-instructions\cline-specific.md** - Cline 特定规则和最佳实践

**MCP 工具使用：**
- **Filesystem MCP** - 文件操作
- **Memory MCP** - 知识图谱管理
- **GitHub MCP** - 代码版本控制
- **Puppeteer MCP** - 浏览器自动化测试

---

## 推荐阅读

- **Clean Code** by Robert C. Martin
- **The Pragmatic Programmer** by Andrew Hunt and David Thomas
- **Code Complete** by Steve McConnell
- **Refactoring** by Martin Fowler
- **Design Patterns** by Gang of Four

---

**记住：** 好的代码应该像散文一样易读！
