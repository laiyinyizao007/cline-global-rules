# ACT MODE - 实现模式工作流程

**在每次代码实现/更改之前，务必执行以下 2 件事：**
a. 阅读并理解 `docs/` 和 `tasks/` 中的文档
b. 从 `src` 和其他位置获取所需的代码上下文

---

## 编程原则

**<编程原则 PROGRAMMING PRINCIPLES>**
- **算法效率 (algorithm_efficiency)**：使用最高效的算法和数据结构
- **模块化 (modularity)**：编写模块化代码，将复杂逻辑分解为更小的原子部分。尽可能分解为类、文件、目录、模块、函数等
- **文件管理 (file_management)**：将长文件分解为更小、更易管理的文件和更小的函数
- **导入语句 (import_statements)**：优先从其他文件导入函数，而不是直接修改这些文件
- **文件组织 (file_organization)**：将文件组织到目录和文件夹中
- **重用 (reuse)**：优先重用现有代码，而不是从头编写
- **代码保留 (code_preservation)**：保留有效的内容。不要在没有必要的情况下修改工作组件
- **系统化顺序 (systematic_sequence)**：在开始另一步之前完全完成一步。保持功能的系统化顺序
- **设计模式 (design_patterns)**：应用适当的设计模式以实现可维护性。为未来的变化做计划，可扩展、灵活、可扩展且可维护的代码
- **主动测试 (proactive_testing)**：任何功能代码都应附带 <测试> 中的适当测试代码

---

## 系统化编码协议

### [步骤 1] 分析代码
**<分析代码 ANALYZE CODE>**

**<依赖分析 DEPENDENCY ANALYSIS>**
- 哪些组件将受到影响？
- 存在哪些依赖关系？
- 这是局部的还是影响核心逻辑？
- 哪些功能将受到影响以及如何受影响？
- 此更改将产生什么连锁效应？

**<流程分析 FLOW ANALYSIS>**
- 在提出任何更改之前，对相关用例从入口点（例如，函数调用、变量初始化）到所有受影响代码的执行进行完整的端到端流程分析
- 跟踪数据和逻辑在所有相关组件中的流动，以了解其完整范围

- 彻底记录这些依赖关系，包括 memory.mdc 中指定的文件中函数或逻辑的具体用法

### [步骤 2] 计划代码
**<计划代码 PLAN CODE>**
- 如果需要，启动 <明确化> 过程
- 使用 <逐步推理> 来概述详细计划，包括组件依赖关系、架构考虑，然后再编码
- 使用 <推理展示> 来解释所有代码更改、每个部分的作用以及它如何影响其他区域

**<结构化提案 STRUCTURED PROPOSALS>**
提供一个提案，指定：
1. 正在更改哪些文件、函数或代码行
2. 为什么需要更改（即错误修复、改进或新功能）
3. 所有直接受影响的模块或文件
4. 潜在的副作用
5. 对任何权衡的详细解释

### [步骤 3] 进行更改
**<进行更改 MAKE CHANGES>**

1. **在 memory.mdc 指定的文件中记录当前状态**
   - 目前有什么工作？
   - 当前的错误/问题是什么？
   - 哪些文件将受到影响？

2. **一次计划一个逻辑更改**
   **<增量推出 INCREMENTAL ROLLOUTS>**
   - 一次一个逻辑功能
   - 但通过在代码的其他部分进行适当的更改来完全解决这一更改
   - 调整此更改创建的所有现有依赖关系和问题
   - **架构保留 (architecture_preservation)**：确保所有新代码在提交更改之前与现有项目结构和架构无缝集成。不要进行破坏现有代码组织或文件的更改

3. **模拟测试**
   **<模拟分析 SIMULATION ANALYSIS>**
   - 通过执行试运行、跟踪调用或其他适当方法来模拟用户交互和行为，以严格分析建议的更改对预期和边缘情况场景的影响
   - 生成关于所有潜在副作用的反馈
   
   **<模拟验证 SIMULATION VALIDATION>**
   - 除非模拟通过并验证所有现有功能都得到保留，否则不要提出更改，如果模拟中断，请在继续之前立即提供修复
   - 如果模拟测试通过，则进行实际实现

### [步骤 4] 执行测试
执行 <测试 TESTING>（见下文）

### [步骤 5] 循环步骤 1-4 并实现所有更改
- 系统地逐一整合所有更改
- 逐一验证和测试更改

### [步骤 6] 优化实现的代码
- 在所有更改经过测试和验证后，优化实现的代码

---

## 参考

**<参考 REFERENCE>**
- 参考相关文档和最佳实践
- 如果需要参考文档或最佳实践，使用 <网络使用>

---

## 测试（实现后始终编写测试）

**<测试 TESTING>**

### 基于依赖的测试
**<基于依赖的测试 DEPENDENCY BASED TESTING>**
为任何新功能创建单元测试。运行 <分析代码> 中的所有测试，以确认现有行为仍然符合预期。

**<无破坏断言 NO BREAKAGE ASSERTION>**
在您提出更改后，自己运行测试，并验证它是否通过。不要依赖我来做这件事，并确保我的代码不会被破坏。

1. **在单独的文件中编写测试逻辑**，与功能的代码实现分开，以保持代码清洁和可维护

### 测试计划
**<测试计划 TEST PLAN>**
- 针对添加/更新的功能，针对需求和期望结果考虑足够详尽的测试计划
- 定义涵盖边缘情况的全面测试场景
- 为项目的技术栈指定适当的验证方法
- 建议监控方法以验证解决方案的有效性
- 考虑潜在的回归以及如何防止它们

2. **始终为任何添加的关键功能编写测试代码**。对于初始测试生成，使用 <基于依赖的测试> 和 <无破坏断言>。然后使用 <测试计划> 编写代码进行广泛测试。

3. 按照 memory.mdc 中的规定记录测试

**在实现新内容时，要不懈努力，逐字逐句地实现所有内容。只有在成功测试完成后才停止，之前不要停止。**

---

## 中文编码规范整合

在实现过程中，请严格遵循：

### Clean Code 原则
- **清晰沟通**：使用简洁明了的语言和命名
- **代码质量**：遵循 Clean Code 原则，编写可读性强的代码
- **最佳实践**：遵循项目现有的代码风格

### 命名规范
- **变量**：描述性名称（`user_count`，`is_active`）
- **函数**：动词开头（`calculate_total_price`，`validate_user_input`）
- **类**：名词，帕斯卡命名法（`UserAccount`，`OrderProcessor`）

### 函数设计
- 函数应该简短（通常 < 20 行）
- 一个函数只做一件事
- 使用描述性的函数名
- 参数数量合理（< 3 个为宜）

### 错误处理
- 使用具体的异常类型
- 提供清晰的错误信息
- 添加适当的日志记录

参考：
- **C:\Dev\rules\ai-instructions\general-rules.md** - 详细的中文编码规范
- **C:\Dev\rules\ai-instructions\cline-specific.md** - Cline 特定功能

---

**在每次代码实现/更改之后，务必执行以下 2 件事：**
a. 更新 `src` 和其他位置可能受影响的代码
b. 更新 `docs/` 和 `tasks/` 中的文档
